

/*
Γράψτε ένα πρόγραμμα C με τις κατάλληλες εντολές fork() ώστε να δημιουργηθούν συνολικά (μαζί με το κυρίως
πρόγραμμα) επτά διεργασίες, με την ακόλουθη δομή (δέντρο) συγγένειας:
P0
 / \
 P1 P2
 / \ / \
P3 P4 P5 P6
Στη συνέχεια (αφού δημιουργηθούν δηλαδή όλες οι διεργασίες που υπαγορεύονται από το παραπάνω δέντρο), ως
κύριο μέρος της εργασίας της κάθε διεργασία Pi θα πρέπει να τυπώνει ένα μήνυμα στην οθόνη που να δηλώνει το
όνομά της (Pi), το PID της και το PPID της. Επιπλέον, το πρόγραμμά σας θα πρέπει να συμπεριλαμβάνει τις
κατάλληλες εντολές αναμονής-επικοινωνίας ώστε να ικανοποιούνται οι ακόλουθοι περιορισμοί-απαιτήσεις:
(α) Η διεργασία P0 πριν ολοκληρώσει την εκτέλεσή της θα πρέπει να περιμένει την ολοκλήρωση της διεργασίας P2.
Με το πέρας της εκτέλεσής της η P0 θα πρέπει επίσης να αντικαθίσταται από την εντολή ps.
(β) Η διεργασία P1 πριν ολοκληρώσει την εκτέλεσή της θα πρέπει αρχικά να περιμένει να λάβει ένα μήνυμα 'hello
from your child' από τη διεργασία P3 (και να το τυπώνει στην οθόνη). Στη συνέχεια θα πρέπει να περιμένει επίσης
την ολοκλήρωση της διεργασίας P4 και να τυπώνει το exit value αυτής.
(γ) Η διεργασία P2 πριν ολοκληρώσει την εκτέλεσή της θα πρέπει να περιμένει την ολοκλήρωση ενός εκ των δύο
παιδιών της και να τυπώνει ποιο είναι αυτό (το PID δηλαδή της διεργασίας-παιδιού που ολοκληρώθηκε).
Επεκτείνατε επίσης το πρόγραμμά σας έτσι ώστε η διεργασία P2 να δημιουργεί Ν διεργασίες/άμεσα παιδιά (αντί για
τις δύο μόνο διεργασίες/άμεσα παιδιά P5,P6 που φαίνεται να δημιουργεί στο παραπάνω σχήμα), όπου το N θα
δίνεται από το χρήστη. Κάθε μία από τις Ν διεργασίες που θα δημιουργηθούν θα πρέπει να τυπώνει απλά ένα
διαγνωστικό μήνυμα με το PID της και το PPID της και να τερματίζει.
Είναι πιθανό κατά την εκτέλεση του προγράμματός σας να δημιουργηθούν orphan ή zombie διεργασίες; Και ποιες
μπορεί να είναι αυτές; Σχολιάστε / τεκμηριώστε επαρκώς την απάντησή σας.
*/

//Απάντηση :

#include <stdio.h>
#include <stdlib.h> 
#include <unistd.h>
#include <sys/wait.h> 
 // Τρέχει ήδη με την εκτέλεση του προγραμμάτος η γονική διεργασία 0
 // Πριν περάσουμε στο κύριο πρόγραμμα, θα ήθελα να κάνω κάποια σχόλια μιας και δε θέλω να επαναλαμβάνω τα σχόλια στον κώδικα προκειμένου να μην είναι κουραστικό
 // Η fork() αν επιστρέψει 0, τότε σημαίνει πως δημιουργείται παιδί. Αν δώσει >0 τότε σημαίνει πως είμαστε στην γονική διεργασία. Αν δώσει -1, τότε ειναι error
 // Η δήλωση pid_t είναι ακεραίος ο οποίος αρμόζει καλύτερα στη δήλωση και την δημιουργία των fork()
 // Η waitpid() δέχεται ως πρώτο όρισμα την διεργασία, το status της και το option. 
int main() {
    pid_t pid1, pid2, pid3, pid4, pid5, pid6; // δήλωση των 6 διεργασιών που ζητάει η εκφώνηση
    int status; // δήλωση ένος status για την αναμόνη της διεργασίας 4 

    pid1 = fork(); //δημιουργία της πρώτης διεργασίας
    if (pid1 == 0) { // έλεγχος αν το fork() γυρνάει παιδί
        pid3 = fork(); //αν γυρνάει παιδί, τότε κάνει fork() για τα παιδιά της 1
        if (pid3 == 0) { // αν γυρνάει παιδί, τότε
            printf("P3 with pid %d and ppid %d\n", getpid(), getppid()); // εμφάνισε pid και ppid της 3
        }
        else { // αλλιώς 
            waitpid(pid3, NULL, 0);  // περιμένει να ολοκληρωθεί η 3 με την εντολή waitpid 
            pid4 = fork(); // δημιουργία της διεργασία 4
            if (pid4 == 0) { // αν δώσει παιδί η fork()
                printf("P4 with pid %d and ppid %d\n", getpid(), getppid()); // εμφάνισε pid και ppid της p4
                exit(123);  // και κάνει exit απο την 4 με ένα συγκεκριμένο value προκειμένου να περάσει το value της στην waitpid()
            }
            else {
                waitpid(pid4, &status, 0);  // περιμένει την 4 να ολοκληρωθεί και στο status θα περαστεί η τιμή exit value της 4. (status = 123)
                printf("P1 with pid %d and ppid %d received message 'hello from your child '\n", getpid(), getppid());  // εμφανίζει το μήνυμα που έλαβε μαζί
                // με το pid και το ppid της 1
                printf("P1 with pid %d and ppid %d received exit status of P4: %d\n", getpid(), getppid(), WEXITSTATUS(status)); // εμφανίζει ξανά 
                // το pid και το ppid της 1 και το exit status της 4 ( απο την exit(123))
            }
        }
    }
    else if (pid1 > 0) { // αλλιώς αν βρισκόμαστε ακόμη στη γονική εφόσον η 1 φέρει τιμή >1
        pid2 = fork(); // κανε fork() και δημιούργησε τη 2
        if (pid2 == 0) { // αν δώσει παιδί το fork()
            int n; // δήλωσε έναν ακέραιο 
            printf("Enter the number of processes to create for P2: "); // εκτύπωσε 
            scanf("%d", &n); // και διάβασε απο το standard input τον αριθμό των διεργασιών που θέλει ο χρήστης να φτιαχτούν
            for (int i = 0; i < n; i++) { // για κάθε μια απο τις διεργασίες
                pid_t child_pid = fork(); // δήλωσε μια μεταβλήτη που δημιουργεί ένα παιδί n φορές
                if (child_pid == 0) { // αν το fork() δώσει παιδί τότε
                    printf("Child %d of P2 with pid %d and ppid %d\n", i+1, getpid(), getppid()); // εμφάνισε τα pid και ppid του κάθε παιδιού
                    exit(9);  
                }
            }
           
        }
        else if (pid2 > 0) {  // αλλιώς
            waitpid(pid2, NULL, 0);  // περιμένει να ολοκληρωθεί η 2 προκειμένου να τρέξει η 0
            printf("P0 with pid %d and ppid %d\n", getpid(), getppid()); // εμφνιζεί pid και ppid της p0
            system("ps"); // με την εντολή system("ps") εμφανίζουμε την εντολή του terminal ps μέσα στη C. Στην ουσία, μας δίνει την δυνατότητα 
            // να βάζουμε εντολές του λειτουργικού linux ως εντολές στην C.
        }
    }

    return 0;
}

//Κατά το τρέξιμο του προγραμμάτος, διαπυστώνουμε πως στη δημιουργία των N processes, δημιουργούνται orphan processes. Αυτό συμβαίνει καθώς κατά τη δημιουργία
//άλλου process, ενδεχομένως να μην καθαρίζονται οι buffers . Με άλλα λόγια, το "σκότωμα" μιας διεργασίας να μην είναι ομαλό και έτσι να μην καθαρίζονται 
// τα απαραίτητα resources με αποτέλεσμα την δημιουργία των orphans.
